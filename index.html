<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SURROGAT — fixed</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    body{margin:0;background:#000;color:#fff;font-family:sans-serif;overflow:hidden}
    h1{font-size:42px;margin:40px auto 20px;text-align:center;background:linear-gradient(90deg,#00ff41,#b026ff);-webkit-background-clip:text;-webkit-text-fill-color:transparent}
    .btn{background:linear-gradient(90deg,#00ff41,#b026ff);color:#000;font-weight:900;font-size:24px;padding:22px;border-radius:25px;border:none;width:88%;margin:15px auto;display:block;box-shadow:0 15px 40px rgba(0,255,65,0.5);cursor:pointer}
    .back{position:fixed;top:15px;left:15px;background:rgba(255,255,255,0.2);padding:12px 20px;border-radius:50px;z-index:999;cursor:pointer}
    .switch{position:fixed;bottom:100px;left:50%;transform:translateX(-50%);background:rgba(255,255,255,0.3);padding:15px 40px;border-radius:50px;z-index:999;cursor:pointer}
    video{width:100vw;height:100vh;object-fit:cover}
    .item{background:#111;margin:12px 0;padding:18px;border-radius:15px;display:flex;justify-content:space-between;align-items:center}
    .item p{margin:0;color:#0f0;font-weight:700}
    .private-btn{background:#b026ff;color:#fff;padding:12px 28px;border-radius:12px;border:none;font-weight:700;cursor:pointer}
    .status{position:fixed;bottom:0;left:0;right:0;background:rgba(0,120,0,0.9);padding:18px;color:#0f0;text-align:center;font-size:19px}
    #online{max-height:60vh;overflow:auto}
    .small{font-size:13px;color:#aaa}
  </style>
</head>
<body>

  <div id="main">
    <h1>SURROGAT</h1>
    <button class="btn" id="watchBtn">ОНЛАЙН НОСИТЕЛИ</button>
    <button class="btn" id="carrierBtn">Я НОСИТЕЛЬ — НАЧАТЬ</button>
    <p style="text-align:center" class="small">Версия: fixed — безопасная работа с WebSocket и стабильный список</p>
  </div>

  <div id="list" style="display:none;padding-bottom:80px">
    <div class="back" id="backFromList">Назад</div>
    <h1>Онлайн носители</h1>
    <div id="online" style="padding:20px"></div>
  </div>

  <div id="stream" style="display:none">
    <div class="back" id="backFromStream">Назад</div>
    <h1 style="text-align:center;margin-top:20px">Ведёшь эфир</h1>
    <video autoplay playsinline muted id="localVideo" style="transform:scaleX(-1)"></video>
    <div class="switch" id="switchCam">Сменить камеру</div>
    <div class="status" id="statusBar">Статус</div>
  </div>

  <script>
    const tg = Telegram.WebApp;
    try { tg.ready(); tg.expand(); } catch (e) { console.warn('Telegram WebApp not available', e); }

    const name = tg?.initDataUnsafe?.user?.first_name || "Гость";

    // WebSocket URL (оставил ваш URL, при необходимости замените)
    const WS_URL = 'wss://surrogat-open.deno.dev';

    // --- WebSocket wrapper: очередь сообщений, авто-переподключение, ping/pong ---
    let ws = null;
    let wsQueue = [];
    let reconnectTimer = null;
    let reconnectAttempts = 0;
    let pingInterval = null;

    function createWebSocket() {
      if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) return;
      ws = new WebSocket(WS_URL);

      ws.addEventListener('open', () => {
        console.log('WS open');
        reconnectAttempts = 0;
        // send queued messages
        while (wsQueue.length) ws.send(wsQueue.shift());
        startPing();
      });

      ws.addEventListener('message', onWSMessage);

      ws.addEventListener('close', e => {
        console.warn('WS closed', e);
        stopPing();
        scheduleReconnect();
      });

      ws.addEventListener('error', e => {
        console.error('WS error', e);
        // ошибка приведёт к close — обработчик close выполнится
      });
    }

    function scheduleReconnect() {
      if (reconnectTimer) return;
      reconnectAttempts++;
      const timeout = Math.min(10000, 1000 * Math.pow(1.5, reconnectAttempts));
      console.log('Reconnecting in', timeout);
      reconnectTimer = setTimeout(() => {
        reconnectTimer = null;
        createWebSocket();
      }, timeout);
    }

    function sendSafe(obj) {
      const s = JSON.stringify(obj);
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(s);
      } else {
        // queue to send later
        wsQueue.push(s);
        createWebSocket();
      }
    }

    function startPing() {
      stopPing();
      pingInterval = setInterval(() => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          try { ws.send(JSON.stringify({type:'ping', t:Date.now()})); } catch (e) { console.warn('Ping failed', e); }
        }
      }, 25000);
    }

    function stopPing() { if (pingInterval) { clearInterval(pingInterval); pingInterval = null; } }

    // Инициализация сразу, но без отправки join — посылаем при необходимости
    createWebSocket();

    // UI references
    const mainEl = document.getElementById('main');
    const listEl = document.getElementById('list');
    const streamEl = document.getElementById('stream');
    const onlineDiv = document.getElementById('online');
    const localVideo = document.getElementById('localVideo');
    const statusBar = document.getElementById('statusBar');

    // Переменные состояния
    let localStream = null;
    let myRoomId = null; // существует, если мы в эфире
    let listUpdater = null;

    // Обработчики UI
    document.getElementById('watchBtn').addEventListener('click', () => watch());
    document.getElementById('carrierBtn').addEventListener('click', () => carrier());
    document.getElementById('backFromList').addEventListener('click', () => showMainFromList());
    document.getElementById('backFromStream').addEventListener('click', () => stopStreamAndShowMain());
    document.getElementById('switchCam').addEventListener('click', () => switchCam());

    // Показываем список — зритель
    function watch() {
      mainEl.style.display = 'none';
      streamEl.style.display = 'none';
      listEl.style.display = 'block';
      // зарегистрироваться как зритель (опционально)
      sendSafe({type:'viewer_join', name});
      updateList();
      if (!listUpdater) listUpdater = setInterval(updateList, 3000);
    }

    function showMainFromList() {
      listEl.style.display = 'none';
      if (listUpdater) { clearInterval(listUpdater); listUpdater = null; }
      // уведомим сервер что мы больше не зритель
      sendSafe({type:'viewer_leave', name});
      mainEl.style.display = 'block';
    }

    // Начать эфир — носитель
    async function carrier() {
      try {
        localStream = await navigator.mediaDevices.getUserMedia({video:true, audio:true});
        myRoomId = 'room_' + Date.now() + '_' + Math.random().toString(36).substr(2,6);

        // Показываем UI стрима
        mainEl.style.display = 'none';
        listEl.style.display = 'none';
        streamEl.style.display = 'block';
        localVideo.srcObject = localStream;
        statusBar.innerHTML = `Ты в эфире как <b>${escapeHtml(name)}</b>`;

        // Отправляем join на сервер
        sendSafe({type:'join', roomId: myRoomId, name});

      } catch (e) {
        alert('Камера не доступна: ' + (e && e.message ? e.message : e));
        console.error(e);
      }
    }

    // Остановить эфир корректно
    function stopStreamAndShowMain() {
      if (localStream) {
        // остановим все треки
        localStream.getTracks().forEach(t => t.stop());
        localStream = null;
      }
      if (myRoomId) {
        sendSafe({type:'leave', roomId: myRoomId, name});
        myRoomId = null;
      }
      // вернуться в главное меню
      streamEl.style.display = 'none';
      mainEl.style.display = 'block';
    }

    // Обновить список онлайн
    function updateList() {
      // отправляем запрос только если socket готов или поставим в очередь
      sendSafe({type:'list'});
    }

    // Обработка входящих сообщений от сервера
    function onWSMessage(e) {
      let d;
      try { d = JSON.parse(e.data); } catch (err) { console.warn('Invalid JSON', e.data); return; }

      // поддерживаем несколько возможных типов
      const list = d.users || d.online || d.list || null;
      if (Array.isArray(list)) {
        renderList(list);
        return;
      }

      // ответ на join/leave
      if (d.type === 'joined') {
        console.log('Server ack joined', d);
      }
      if (d.type === 'pong') {
        // время отклика
        // console.log('pong', d);
      }

      // diagnostics
      if (d.type && !list) console.log('WS message', d);
    }

    function renderList(users) {
      onlineDiv.innerHTML = '';
      if (users.length === 0) {
        onlineDiv.innerHTML = "<p style='text-align:center;color:#555;padding:50px 0'>Пока никого нет</p>";
        return;
      }

      users.forEach(u => {
        const el = document.createElement('div');
        el.className = 'item';
        const nameText = escapeHtml(u.name || u.nick || 'Аноним');
        el.innerHTML = `<p>${nameText}</p><button class='private-btn'>ПРИВАТ</button>`;
        // кнопка приват — пока заглушка
        el.querySelector('button').addEventListener('click', () => alert('Приватный стрим с ' + nameText + ' скоро здесь'));
        onlineDiv.appendChild(el);
      });
    }

    // Смена камеры (пробуем поменять facingMode)
    async function switchCam() {
      if (!localStream) return;
      const videoTrack = localStream.getVideoTracks()[0];
      const settings = videoTrack.getSettings ? videoTrack.getSettings() : {};
      const currentFacing = settings.facingMode || 'user';
      const newFacing = currentFacing === 'user' ? 'environment' : 'user';
      try {
        const newStream = await navigator.mediaDevices.getUserMedia({video:{facingMode:newFacing}, audio:true});
        // заменяем в UI
        localVideo.srcObject = newStream;
        // останавливаем старые треки
        localStream.getTracks().forEach(t => t.stop());
        localStream = newStream;
      } catch (e) {
        console.warn('Switch camera failed', e);
        alert('Не удалось сменить камеру: ' + (e && e.message ? e.message : e));
      }
    }

    // Безопасный escape для вставки имён в HTML
    function escapeHtml(str){ return String(str).replace(/[&<>"']/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[s])); }

    // Отправка leave при закрытии страницы
    window.addEventListener('beforeunload', () => {
      try {
        if (myRoomId) sendSafe({type:'leave', roomId: myRoomId, name});
        sendSafe({type:'viewer_leave', name});
        // Закрыть ws корректно
        if (ws && ws.readyState === WebSocket.OPEN) ws.close();
      } catch (e) { /* ignore */ }
    });

    // Если нужно — можно вызвать ручной reconnect по тапу (ключ: long press или тд.)

  </script>
</body>
</html>
